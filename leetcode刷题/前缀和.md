![[Pasted image 20240319121324.png]]
对于子数组的和(子串) 也就是说如果是涉及到连续的一段数字求和，那么使用前缀和是非常好的，因为把一段连续数字的和转化为了前缀和数组的两个index的差，那么对于这道题来说，如果要找和为k的子数组的个数，那么说明就是找前缀和数组有多少对index满足presum[index1] - presum[index2] = k

这里有个难点是前缀和和原数组的下标问题。
我们的前缀和数组是从0开始的，即0个元素的前缀和是0，从而前缀和的数组长度为n+1，那么索引的时候：
- 如果从原数组的角度来说，则应该是presum[j+1] - presum[i]求得从[i,j]闭区间的和

所以对于这道题，我们就是有多少个下标满足前缀和之差为k。
我们可以采用两数之和的方法去做，构建hash表（这里hash表保存每个数字对应的出现次数），去找右边那个数字，枚举presum中的每个数字，查找hash表中是否存在presum-k，如果存在的话，则count+=hashtable[presum-k]，然后把当前的数字放进hashtable，然后次数加一。

```python

```