第一题：
[替换后的最长重复字符](https://leetcode.cn/problems/longest-repeating-character-replacement/)
![[Pasted image 20230410210139.png]]
这道题使用了[[滑动窗口法]]

关键是看出k是怎么在滑动窗口里用的，由于是可以随意更改字符串里的字符共k个，其实就是表明了 **最长子字符串里的容错数是k个，即允许有k个字符和其他字符不一样 
如果感知到这个关键信息，那么就很好写滑动窗口了，关键的不等式即是：

**最大子字符串长度 <= 最多出现的子字符串长度 + k

```python
class Solution:
    def characterReplacement(self, s: str, k: int) -> int:
        left = 0
        right = 0
        from collections import defaultdict
        hash_dict = defaultdict(int)
        maxlength = float('-inf')
        maxcount = float('-inf')
        while(right<len(s)):
        
            hash_dict[s[right]] = hash_dict[s[right]] + 1
            
            if hash_dict[s[right]] > maxcount:
                maxcount = hash_dict[s[right]]
                
            while(right - left + 1 - maxcount > k):
                hash_dict[s[left]] = hash_dict[s[left]] - 1
                left += 1
                
            if right - left + 1 > maxlength:
                maxlength = right - left + 1
                
            right += 1
        return maxlength
```

这里有个小技巧使用`s[right]`在滑动过程中，直接加到hashmap之中，然后从而每一步都更新最大值从而就能得到hashmap在window中的数量最大值。因为某个元素`s[right]`出现最大值只可能是在+1之后，否则之前的max_cnt就是数量最大值。
其中`while()`循环中的条件就是关键：

`right - left + 1 - maxcount > k`

**最大子字符串长度 = `right - left + 1`
**最大子字符串长度 = `right - left + 1`