第一题：
[替换后的最长重复字符](https://leetcode.cn/problems/longest-repeating-character-replacement/)
![[Pasted image 20230410210139.png]]
这道题使用了[[滑动窗口法]]

关键是看出k是怎么在滑动窗口里用的，由于是可以随意更改字符串里的字符共k个，其实就是表明了 **最长子字符串里的容错数是k个，即允许有k个字符和其他字符不一样 
如果感知到这个关键信息，那么就很好写滑动窗口了，关键的不等式即是：

**最大子字符串长度 <= 最多出现的子字符串长度 + k

```python
class Solution:
    def characterReplacement(self, s: str, k: int) -> int:
        left = 0
        right = 0
        from collections import defaultdict
        hash_dict = defaultdict(int)
        maxlength = float('-inf')
        maxcount = float('-inf')
        while(right<len(s)):
        
            hash_dict[s[right]] = hash_dict[s[right]] + 1
            
            if hash_dict[s[right]] > maxcount:
                maxcount = hash_dict[s[right]]
                
            while(right - left + 1 - maxcount > k):
                hash_dict[s[left]] = hash_dict[s[left]] - 1
                left += 1
                
            if right - left + 1 > maxlength:
                maxlength = right - left + 1
                
            right += 1
        return maxlength
```

这里有个小技巧使用`s[right]`在滑动过程中，直接加到hashmap之中，然后从而每一步都更新最大值从而就能得到hashmap在window中的数量最大值。因为某个元素`s[right]`出现最大值只可能是在+1之后，否则之前的max_cnt就是数量最大值。
其中`while()`循环中的条件就是关键：

`right - left + 1 - maxcount > k`

**最大子字符串长度 = `right - left + 1`
最多出现的子字符串长度 = `maxcount`

注意这里 `right += 1` 是放在最后的，和之前的那些滑动窗口算法的位置不太一样，注意不要太死板

第一题拓展：
[单字符重复子串的最大长度](https://leetcode.cn/problems/swap-for-longest-repeated-character-substring/)
![[Pasted image 20230410214436.png]]
这里的算法和第一题非常的类似，可以理解为先任意替换，k=1，最后替换完之后要检查一下能不能替换，即例如上面的a够不够？最后返回`a`的最多数目和最长子序列。

这里和上面不一样的就是需要不断的维护