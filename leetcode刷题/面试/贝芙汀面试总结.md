# 第一题：
[替换后的最长重复字符](https://leetcode.cn/problems/longest-repeating-character-replacement/)
![[Pasted image 20230410210139.png]]
这道题使用了[[滑动窗口法]]

关键是看出k是怎么在滑动窗口里用的，由于是可以随意更改字符串里的字符共k个，其实就是表明了 **最长子字符串里的容错数是k个，即允许有k个字符和其他字符不一样 
如果感知到这个关键信息，那么就很好写滑动窗口了，关键的不等式即是：

**最大子字符串长度 <= 最多出现的子字符串长度 + k

```python
class Solution:
    def characterReplacement(self, s: str, k: int) -> int:
        left = 0
        right = 0
        from collections import defaultdict
        hash_dict = defaultdict(int)
        maxlength = float('-inf')
        maxcount = float('-inf')
        while(right<len(s)):
        
            hash_dict[s[right]] = hash_dict[s[right]] + 1
            
            if hash_dict[s[right]] > maxcount:
                maxcount = hash_dict[s[right]]
                
            while(right - left + 1 - maxcount > k):
                hash_dict[s[left]] = hash_dict[s[left]] - 1
                left += 1
                
            if right - left + 1 > maxlength:
                maxlength = right - left + 1
                
            right += 1
        return maxlength
```

这里有个小技巧使用`s[right]`在滑动过程中，直接加到hashmap之中，然后从而每一步都更新最大值从而就能得到hashmap在window中的数量最大值。因为某个元素`s[right]`出现最大值只可能是在+1之后，否则之前的max_cnt就是数量最大值。
其中`while()`循环中的条件就是关键：

`right - left + 1 - maxcount > k`

**最大子字符串长度 = `right - left + 1`
最多出现的子字符串长度 = `maxcount`

注意这里 `right += 1` 是放在最后的，和之前的那些滑动窗口算法的位置不太一样，注意不要太死板

# 第一题拓展1：
[单字符重复子串的最大长度](https://leetcode.cn/problems/swap-for-longest-repeated-character-substring/)
![[Pasted image 20230410214436.png]]
这里的算法和第一题非常的类似，可以理解为先任意替换，k=1，最后替换完之后要检查一下能不能替换，即例如上面的a够不够？最后返回`a`的最多数目和最长子序列。
```python
class Solution:
    def maxRepOpt1(self, text: str) -> int:
        left = 0
        right = 0
        from collections import defaultdict
        hash_dict_all = defaultdict(int)
        for i in text:
            hash_dict_all[i] += 1
        max_length = 0
        now_element = ''
        max_cnt_ = 0
        window = []
        while(right<len(text)):
            window.append(text[right])
            
            max_cnt_ = 0
            cnt = defaultdict(int)
            for i in window:
                cnt[i] += 1
                if cnt[i] > max_cnt_:
                    max_cnt_ = cnt[i]
                    now_element = i    

            while (right - left + 1 - max_cnt_ > 1):
                del(window[0])
                max_cnt_ = 0
                cnt = defaultdict(int)
                for i in window:
                    cnt[i] += 1
                    if cnt[i] > max_cnt_:
                        max_cnt_ = cnt[i]
                        now_element = i    
                left += 1
            max_cnt_ = 0
            cnt = defaultdict(int)
            
            for i in window:
                cnt[i] += 1
                if cnt[i] > max_cnt_:
                    max_cnt_ = cnt[i]
                    now_element = i       

            length = min(right - left + 1, hash_dict_all[now_element])
            max_length = max(max_length,length)
            right += 1
            
        return max_length
```
这里和上面不一样的就是需要不断的维护max_cnt因为最后需要找出谁最大，而第一题不需要知道具体谁最多

# 第一题拓展2
![[Pasted image 20230410222047.png]]
这道题使用Rabin-Karp算法＋二分法进行求解

# 第二题

### 矩阵的螺旋遍历
[螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/)
[螺旋矩阵 II](https://leetcode.cn/problems/spiral-matrix-ii/)

![[Pasted image 20230410234118.png]]

螺旋遍历的方法是通过设定4个边界然后利用边界来一步一步的往内推进
![[Pasted image 20230410234336.png]]
![[Pasted image 20230410234350.png]]

