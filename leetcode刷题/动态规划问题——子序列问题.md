 ### **对于动态规划的子序列问题，一般两种求解方式：
1.自顶向下利用DP函数进行求解
2.利用DP table顶底向上进行求解
	其中DP table在子序列中的定义方法有以下几种:
	①定义以`nums[i]`结尾的DP_table
	②定义以`nums[...i]`的针对前i个的DP_table
	③定义以`nums[i...]`的针对从第i个开始的DP_table

# 1.最长递增子序列
[300. 最长递增子序列 - 力扣（Leetcode）](https://leetcode.cn/problems/longest-increasing-subsequence/)
![[Pasted image 20230411135635.png]]
这种一维数组的题其实最简单的想法就是用DP table然后使用递推公式去想，即我由`DP[i-1]`怎么去推到`DP[i]`
一般的想法就是把前面三种DP table的定义方法都试一遍，然后看看哪种可以形成递推
如果使用
②定义以`nums[...i]`的针对前i个的DP_table
那么对于`dp_table[i]`表示`nums`前`i`个中的最长递增序列长度为`i`
如果这样定义可以由`dp_table[i-1]`递推出`dp_table[i]`吗？
这样是不行的，因为前i个的这种定义方式在这里丢失了第i的信息，也就是说当第i个不是递增的时候，第i个就和i-1的一样了，没有区分出来

所以这个时候应该使用定义①
①定义以`nums[i]`结尾的DP_table
这个时候都只计算以`nums[i]`结尾的最长递增子序列，那么对于全局最长子序列需要遍历一遍所有的元素

这个递推公式应该是什么样子的呢？
根据刚才我们对 `dp` 数组的定义，现在想求 `dp[5]` 的值，也就是想求以 `nums[5]` 为结尾的最长递增子序列。

**`nums[5] = 3`，既然是递增子序列，我们只要找到前面那些结尾比 3 小的子序列，然后把 3 接到这些子序列末尾，就可以形成一个新的递增子序列，而且这个新的子序列长度加一**。

`nums[5]` 前面有哪些元素小于 `nums[5]`？这个好算，用 for 循环比较一波就能把这些元素找出来。

以这些元素为结尾的最长递增子序列的长度是多少？回顾一下我们对 `dp` 数组的定义，它记录的正是以每个元素为末尾的最长递增子序列的长度。

以我们举的例子来说，`nums[0]` 和 `nums[4]` 都是小于 `nums[5]` 的，然后对比 `dp[0]` 和 `dp[4]` 的值，我们让 `nums[5]` 和更长的递增子序列结合，得出 `dp[5] = 3`：
![[Pasted image 20230411142124.png]]

所以算法应该是
```python
def lengthOfLIS(nums: List[int]) -> int:
    # 定义：dp[i] 表示以 nums[i] 这个数结尾的最长递增子序列的长度
    dp = [1] * len(nums)
    for i in range(len(nums)):
        for j in range(i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j] + 1) 

    res = 0
    for i in range(len(dp)):
        res = max(res, dp[i])
    return res
```
### 方法二
#### 二分搜索法





# 2.俄罗斯套娃问题

[354. 俄罗斯套娃信封问题](https://leetcode.cn/problems/russian-doll-envelopes/)

关键是把套娃问题转化为最长子序列，然后用最长子序列去做
这里采用了一个[[小技巧]]对数组进行排列
**先对宽度 `w` 进行升序排序，如果遇到 `w` 相同的情况，则按照高度 `h` 降序排序。之后把所有的 `h` 作为一个数组，在这个数组上计算 LIS 的长度就是答案。**
`envelopes.sort(key=lambda x: (x[0],-x[1]))`


# 3.子序列的数目
![[Pasted image 20230418185859.png]]
对于这种有两个字符串的题目，且是求最值，所以采用动态规划的方法，对于这种两个字符串的方法，关键是定义出dp table，这里定义dp table为
**`dp[i][j]表明s[i...]和t[i...]共有dp[i][j]中匹配方法`
下面就是写递推关系
这里有两个角度去看这个问题：

**`t` 中的若干字符就好像若干盒子，`s` 中的若干字符就好像若干小球，你需要做的就是给所有盒子都装一个小球。所以这里就有两种穷举思路了，分别是站在 `t` 的视角（盒子选择小球）和站在 `s` 的视角（小球选择盒子）**

从t的视角：

