### **对于动态规划的子序列问题，一般两种求解方式：
1.自顶向下利用DP函数进行求解
2.利用DP table顶底向上进行求解
	其中DP table在子序列中的定义方法有以下几种:
	①定义以`nums[i]`结尾的DP_table
	②定义以`nums[...i]`的针对前i个的DP_table
	③定义以`nums[i...]`的针对从第i个开始的DP_table

# 1.最长递增子序列
[300. 最长递增子序列 - 力扣（Leetcode）](https://leetcode.cn/problems/longest-increasing-subsequence/)
![[Pasted image 20230411135635.png]]
这种一维数组的题其实最简单的想法就是用DP table然后使用递推公式去想，即我由`DP[i-1]`怎么去推到`DP[i]`
一般的想法就是把前面三种DP table的定义方法都试一遍，然后看看哪种可以形成递推
如果使用
②定义以`nums[...i]`的针对前i个的DP_table
那么对于`dp_table[i]`表示`nums`前`i`个中的最长递增序列长度为`i`
如果这样定义可以由`dp_table[i-1]`递推出`dp_table[i]`吗？
这样是不行的，因为前i个的这种定义方式在这里丢失了第i的信息，也就是说当第i个不是递增的时候，第i个就和i-1的一样了，没有区分出来

所以这个时候应该使用定义①
①定义以`nums[i]`结尾的DP_table
这个时候都只计算以`nums[i]`结尾的最长递增子序列，那么对于全局最长子序列需要遍历一遍所有的元素

这个递推公式应该是什么样子的呢？
根据刚才我们对 `dp` 数组的定义，现在想求 `dp[5]` 的值，也就是想求以 `nums[5]` 为结尾的最长递增子序列。

**`nums[5] = 3`，既然是递增子序列，我们只要找到前面那些结尾比 3 小的子序列，然后把 3 接到这些子序列末尾，就可以形成一个新的递增子序列，而且这个新的子序列长度加一**。

`nums[5]` 前面有哪些元素小于 `nums[5]`？这个好算，用 for 循环比较一波就能把这些元素找出来。

以这些元素为结尾的最长递增子序列的长度是多少？回顾一下我们对 `dp` 数组的定义，它记录的正是以每个元素为末尾的最长递增子序列的长度。

以我们举的例子来说，`nums[0]` 和 `nums[4]` 都是小于 `nums[5]` 的，然后对比 `dp[0]` 和 `dp[4]` 的值，我们让 `nums[5]` 和更长的递增子序列结合，得出 `dp[5] = 3`：
![[Pasted image 20230411142124.png]]
